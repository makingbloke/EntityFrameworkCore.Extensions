// Copyright ©2021-2025 Mike King.
// This file is licensed to you under the MIT license.
// See the License.txt file in the solution root for more information.

using Microsoft.EntityFrameworkCore.Diagnostics;
using System.Collections.Concurrent;
using System.Data.Common;
using System.Text.RegularExpressions;

namespace DotDoc.EntityFrameworkCore.Extensions.ExecuteDelete;

/// <summary>
/// Interceptor used to capture the SQL and parameters generated by ExecuteDelete.
/// </summary>
internal sealed partial class ExecuteDeleteGetRowsCommandInterceptor : DbCommandInterceptor
{
    #region internal fields

    /// <summary>
    /// Singleton instance of this interceptor.
    /// </summary>
    internal static readonly ExecuteDeleteGetRowsCommandInterceptor Instance = new();

    #endregion internal fields

    #region private fields

    /// <summary>
    /// Dictionary holding the results of ExecuteDeleteGetRows.
    /// </summary>
    private static readonly ConcurrentDictionary<Guid, ExecuteDeleteQuery> DeleteQueries = new();

    #endregion private fields

    #region private constructors

    /// <summary>
    /// Initializes a new instance of the <see cref="ExecuteDeleteGetRowsCommandInterceptor"/> class.
    /// </summary>
    private ExecuteDeleteGetRowsCommandInterceptor()
    {
    }

    #endregion private constructors

    #region public methods

    /// <inheritdoc/>
    public override ValueTask<InterceptionResult<int>> NonQueryExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
    {
        result = HandleNonQueryExecuting(eventData.CommandSource, command, result);
        return base.NonQueryExecutingAsync(command, eventData, result, cancellationToken);
    }

    #endregion public methods

    #region internal methods

    /// <summary>
    /// Get the SQL and parameters needed to run an Delete statement.
    /// </summary>
    /// <param name="deleteId">The deleteId.</param>
    /// <returns>The result.</returns>
    internal static ExecuteDeleteQuery GetDeleteQuery(Guid deleteId)
    {
        if (!DeleteQueries.TryRemove(deleteId, out ExecuteDeleteQuery? deleteQuery))
        {
            throw new InvalidOperationException($"{nameof(DeleteQueries)} entry not found.");
        }

        return deleteQuery;
    }

    #endregion internal methods

    #region private methods

    /// <summary>
    /// Check if the command executing is an ExecuteDelete and the SQL contains an deleteId.
    /// If it is then store the SQL and parameters then supress the commands execution.
    /// </summary>
    /// <param name="commandSource">Source of command.</param>
    /// <param name="command">The command.</param>
    /// <param name="result">The default return value for this method <see cref="InterceptionResult{int32}"/>.</param>
    /// <returns><paramref name="result"/>.</returns>
    private static InterceptionResult<int> HandleNonQueryExecuting(CommandSource commandSource, DbCommand command, InterceptionResult<int> result)
    {
        if (IsExecuteDelete(commandSource))
        {
            Guid deleteId = GetDeleteId(command.CommandText);

            if (deleteId != Guid.Empty)
            {
                DeleteQueries[deleteId] = new(command.CommandText, command.Parameters.Cast<DbParameter>().ToArray());
                result = InterceptionResult<int>.SuppressWithResult(0);
            }
        }

        return result;
    }

    /// <summary>
    /// Check if a <see cref="CommandSource"/> value is <see cref="CommandSource.ExecuteDelete"/>.
    /// </summary>
    /// <param name="commandSource">The value to check.</param>
    /// <returns><see langword="true"/> if the source is execute delete else, <see langword="false"/>.</returns>
    /// <remarks>
    /// There is an issue with EF core 9 where Db Interceptors can receive an obsolete value in CommandSource
    /// of BulkDelete(8) instead of the (correct) value ExecuteDelete(8). Convert the values to int's to cover
    /// both cases: https://github.com/dotnet/efcore/issues/34678 .
    /// </remarks>
    private static bool IsExecuteDelete(CommandSource commandSource) =>
        (int)commandSource == (int)CommandSource.ExecuteDelete;

    /// <summary>
    /// Get the DeleteId from the SQL comment (Tag) if there is one.
    /// </summary>
    /// <param name="sql">The sql.</param>
    /// <returns>The delete Id (<see cref="Guid"/>) if one is found else, an empty Guid.</returns>
    private static Guid GetDeleteId(string sql)
    {
        Match match = GetDeleteIdRegex().Match(sql);

        Guid deleteId = match.Success
            ? Guid.Parse(match.Groups["DeleteId"].Value)
            : Guid.Empty;

        return deleteId;
    }

    /// <summary>
    /// A regex used to search the SQL for a comment -- ExecuteDeleteGetRows with a <see cref="Guid"/> deleteId in numeric (N) format.
    /// </summary>
    [GeneratedRegex("^-- ExecuteDeleteGetRows (?<DeleteId>[0-9A-Fa-f]{32})\r?$", RegexOptions.Multiline | RegexOptions.ExplicitCapture)]
    private static partial Regex GetDeleteIdRegex();

    #endregion private methods
}