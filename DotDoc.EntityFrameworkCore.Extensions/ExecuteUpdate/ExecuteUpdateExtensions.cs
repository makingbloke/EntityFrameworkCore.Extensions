// Copyright ©2021-2025 Mike King.
// This file is licensed to you under the MIT license.
// See the License.txt file in the solution root for more information.

using DotDoc.EntityFrameworkCore.Extensions.Constants;
using DotDoc.EntityFrameworkCore.Extensions.CustomQueryGenerators;
using DotDoc.EntityFrameworkCore.Extensions.Utilities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using System.Collections.Concurrent;
using System.Data.Common;

namespace DotDoc.EntityFrameworkCore.Extensions.ExecuteUpdate;

/// <summary>
/// Execute Update Extensions.
/// </summary>
public static partial class ExecuteUpdateExtensions
{
    #region private fields

    /// <summary>
    /// Dictionary holding the SQL and parameters for the queries generated by ExecuteDelete/Insert/Update.
    /// </summary>
    private static readonly ConcurrentDictionary<Guid, QueryResult> QueryResults = [];

    #endregion private fields

    #region public UseExecuteUpdateExtensions methods

    /// <summary>
    /// Use the Execute Update Extensions.
    /// </summary>
    /// <param name="optionsBuilder">The builder being used to configure the context.</param>
    /// <returns>The same builder instance so multiple calls can be chained.</returns>
    public static DbContextOptionsBuilder UseExecuteUpdateExtensions(this DbContextOptionsBuilder optionsBuilder)
    {
        ArgumentNullException.ThrowIfNull(optionsBuilder);

        optionsBuilder
            .UseCustomQueryGenerator()
            .AddInterceptors(ExecuteUpdateInterceptor.Instance);

        return optionsBuilder;
    }

    #endregion public UseExecuteUpdateExtensions methods

    #region public ExecuteDeleteGetCountAsync methods

    /// <summary>
    /// Deletes all database rows for the entity instances which match the LINQ query from the database.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">An <see cref="IQueryable{TSource}" /> whose elements to test for a condition.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>The number of rows deleted in the database.</returns>
    public static async Task<int> ExecuteDeleteGetCountAsync<TSource>(this IQueryable<TSource> source, CancellationToken cancellationToken = default)
        where TSource : class
    {
        ArgumentNullException.ThrowIfNull(source);

        int count = await source
            .ExecuteDeleteAsync(cancellationToken)
            .ConfigureAwait(false);

        return count;
    }

    #endregion public ExecuteDeleteGetCountAsync methods

    #region public ExecuteDeleteGetRowsAsync methods

    /// <summary>
    /// Deletes all database rows for the entity instances which match the LINQ query from the database.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">An <see cref="IQueryable{TSource}" /> whose elements to test for a condition.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>An <see cref="IList{TSource}"/> containing the modified rows.</returns>
    public static async Task<IList<TSource>> ExecuteDeleteGetRowsAsync<TSource>(this IQueryable<TSource> source, CancellationToken cancellationToken = default)
        where TSource : class
    {
        ArgumentNullException.ThrowIfNull(source);

        source = TagQuery(source, TagNames.ExecuteDelete, out Guid queryId);

        // Execute the delete and capture SQL and parameters (This just generates the SQL, it is not executed).
        await source.ExecuteDeleteAsync(cancellationToken).ConfigureAwait(false);
        QueryResult queryResult = GetQueryResult(queryId);

        // Execute the delete and get the deleted rows.
        DbContext context = source.GetDbContext();

        List<TSource> results = await context.Database.SqlQueryRaw<TSource>(queryResult.Sql, queryResult.Parameters)
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);

        return results;
    }

    #endregion public ExecuteDeleteGetRowsAsync methods

    #region public ExecuteInsertGetRowAsync methods

    /// <summary>
    /// Insert a database row.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">An <see cref="IQueryable{TSource}" /> whose elements to test for a condition.</param>
    /// <param name="setPropertyCalls">A method containing set property statements specifying properties to update.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>An instance of the <typeparamref name="TSource"/> containing the inserted row or <see langword="null"/> if the row cannot be retrieved.</returns>
    public static async Task<TSource?> ExecuteInsertGetRowAsync<TSource>(this IQueryable<TSource> source, Action<UpdateSettersBuilder<TSource>> setPropertyCalls, CancellationToken cancellationToken = default)
        where TSource : class
    {
        ArgumentNullException.ThrowIfNull(source);
        ArgumentNullException.ThrowIfNull(setPropertyCalls);

        source = TagQuery(source, TagNames.ExecuteInsert, out Guid queryId);

        // Execute the insert and capture SQL and parameters (This just generates the SQL, it is not executed).
        await source.ExecuteUpdateAsync(setPropertyCalls, cancellationToken).ConfigureAwait(false);
        QueryResult queryResult = GetQueryResult(queryId);

        // Execute the insert and get the inserted rows.
        DbContext context = source.GetDbContext();

        List<TSource> results = await context.Database.SqlQueryRaw<TSource>(queryResult.Sql, queryResult.Parameters)
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);

        return results.Count > 0
            ? results[0]
            : null;
    }

    #endregion public ExecuteInsertGetRowAsync methods

    #region public ExecuteUpdateGetCountAsync methods

    /// <summary>
    /// Updates all database rows for the entity instances which match the LINQ query from the database.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">An <see cref="IQueryable{TSource}" /> whose elements to test for a condition.</param>
    /// <param name="setPropertyCalls">A method containing set property statements specifying properties to update.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>The number of rows updated in the database.</returns>
    public static async Task<int> ExecuteUpdateGetCountAsync<TSource>(this IQueryable<TSource> source, Action<UpdateSettersBuilder<TSource>> setPropertyCalls, CancellationToken cancellationToken = default)
        where TSource : class
    {
        ArgumentNullException.ThrowIfNull(source);
        ArgumentNullException.ThrowIfNull(setPropertyCalls);

        int count = await source
            .ExecuteUpdateAsync(setPropertyCalls, cancellationToken)
            .ConfigureAwait(false);

        return count;
    }

    #endregion public ExecuteUpdateGetCountAsync methods

    #region public ExecuteUpdateGetRowsAsync methods

    /// <summary>
    /// Updates all database rows for the entity instances which match the LINQ query from the database.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">An <see cref="IQueryable{TSource}" /> whose elements to test for a condition.</param>
    /// <param name="setPropertyCalls">A method containing set property statements specifying properties to update.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>An <see cref="IList{TSource}"/> containing the modified rows.</returns>
    public static async Task<IList<TSource>> ExecuteUpdateGetRowsAsync<TSource>(this IQueryable<TSource> source, Action<UpdateSettersBuilder<TSource>> setPropertyCalls, CancellationToken cancellationToken = default)
        where TSource : class
    {
        ArgumentNullException.ThrowIfNull(source);
        ArgumentNullException.ThrowIfNull(setPropertyCalls);

        source = TagQuery(source, TagNames.ExecuteUpdate, out Guid queryId);

        // Execute the update and capture SQL and parameters (This just generates the SQL, it is not executed).
        await source.ExecuteUpdateAsync(setPropertyCalls, cancellationToken).ConfigureAwait(false);
        QueryResult queryResult = GetQueryResult(queryId);

        // Execute the update and get the updated rows.
        DbContext context = source.GetDbContext();

        List<TSource> results = await context.Database.SqlQueryRaw<TSource>(queryResult.Sql, queryResult.Parameters)
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);

        return results;
    }

    #endregion public ExecuteUpdateGetRowsAsync methods

    #region internal methods

    /// <summary>
    /// Store the SQL and parameters for a query.
    /// </summary>
    /// <param name="queryId">The query Id.</param>
    /// <param name="sql">The SQL.</param>
    /// <param name="parameters">The parameters.</param>
    internal static void StoreQueryResult(Guid queryId, string sql, DbParameter[] parameters)
    {
        QueryResults[queryId] = new(sql, parameters);
    }

    #endregion internal methods

    #region private methods

    /// <summary>
    /// Tag a query with a name / queryId pair.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">An <see cref="IQueryable{TSource}" /> whose elements to test for a condition.</param>
    /// <param name="name">The tag name.</param>
    /// <param name="queryId">The unique query id (Out).</param>
    /// <returns>The query with the tag added.</returns>
    private static IQueryable<TSource> TagQuery<TSource>(IQueryable<TSource> source, string name, out Guid queryId)
    {
        queryId = Guid.NewGuid();
        return TagCollection.TagQuery(source, name, $"{queryId:N}");
    }

    /// <summary>
    /// Get a query result and remove it from the dictionary.
    /// </summary>
    /// <param name="queryId">The query Id.</param>
    /// <returns>An instance of <see cref="QueryResult"/> containing the SQL and parameters.</returns>
    private static QueryResult GetQueryResult(Guid queryId)
    {
        if (!QueryResults.TryRemove(queryId, out QueryResult? queryResult))
        {
            throw new ArgumentException($"No query result found.", nameof(queryId));
        }

        return queryResult;
    }

    #endregion private methods
}
