// Copyright ©2021-2025 Mike King.
// This file is licensed to you under the MIT license.
// See the License.txt file in the solution root for more information.

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using System.Collections.Concurrent;
using System.Data.Common;
using System.Text.RegularExpressions;

namespace DotDoc.EntityFrameworkCore.Extensions.Interceptors;

/// <summary>
/// Interceptor for collecting the SQL generated by ExecuteUpdateGetRows methods.
/// </summary>
internal sealed partial class ExecuteUpdateGetRowsCommandInterceptor : DbCommandInterceptor
{
    #region internal fields

    /// <summary>
    /// Singleton instance of this interceptor.
    /// </summary>
    internal static readonly ExecuteUpdateGetRowsCommandInterceptor Instance = new();

    /// <summary>
    /// Sentinel result returned when the ExecuteUpdateGetRows command is executed.
    /// </summary>
    internal static readonly int ExecuteUpdateGetRowsSentinelResult = int.MinValue;

    #endregion internal fields

    #region private fields

    /// <summary>
    /// Dictionary holding the collected ExecuteUpdate parameters.
    /// </summary>
    private readonly ConcurrentDictionary<Guid, (DbContext, string, object[])> _updateParameters = new();

    #endregion private fields

    #region private constructors

    /// <summary>
    /// Initializes a new instance of the <see cref="ExecuteUpdateGetRowsCommandInterceptor"/> class.
    /// </summary>
    private ExecuteUpdateGetRowsCommandInterceptor()
    {
    }

    #endregion private constructors

    #region public methods

    /// <inheritdoc/>
    public override ValueTask<InterceptionResult<int>> NonQueryExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
    {
        result = this.HandleNonQueryExecuting(command, eventData, result);
        return base.NonQueryExecutingAsync(command, eventData, result, cancellationToken);
    }

    #endregion public methods

    #region internal methods

    /// <summary>
    /// Fetch the SQL and parameters for an ExecuteUpdateGetRows call.
    /// </summary>
    /// <param name="updateId">The updateId.</param>
    /// <param name="context">The database context (out).</param>
    /// <param name="sql">The sql (out).</param>
    /// <param name="parameters">The parameters (out).</param>
    internal void FetchUpdateParameters(Guid updateId, out DbContext context, out string sql, out object[] parameters)
    {
        if (!this._updateParameters.TryRemove(updateId, out (DbContext Context, string Sql, object[] Parameters) entry))
        {
            throw new InvalidOperationException("Unable to fetch an entry from UpdateParameters");
        }

        context = entry.Context;
        sql = entry.Sql;
        parameters = entry.Parameters;
    }

    #endregion internal methods

    #region private methods

    /// <summary>
    /// Look in the SQL for a comment (EF Core Tag) and the <see cref="Guid"/> updateId.
    /// </summary>
    /// <param name="sql">The sql.</param>
    /// <param name="updateId">The <see cref="Guid"/> updateId (out).</param>
    /// <returns><see langword="true"/> if the comment is found and the updateId has been extracted else, <see langword="false"/>.</returns>
    private static bool GetUpdateId(string sql, out Guid updateId)
    {
        Match match = GetUpdateIdRegex().Match(sql);

        updateId = match.Success
            ? Guid.Parse(match.Groups["UpdateId"].Value)
            : Guid.Empty;

        return match.Success;
    }

    /// <summary>
    /// Make a copy of a commands parameters.
    /// </summary>
    /// <param name="command">The command.</param>
    /// <returns>An array of <see cref="DbParameter"/> objects.</returns>
    /// <remarks>
    /// MK 4/2/2025
    /// We used to clone parameters by coping each individual property (SqlParameter supported ICloneable but SqliteParameter did not)
    /// This caused issues with complicated queries and SQLite (see example below) where even though we were setting the DbType property
    /// correctly, no results were being updated because it looked like EF core was not converting the date into a string (With EF Core
    /// SQLite usually stores dates as strings). So, as this query will never get executed and we are using the same context we are
    /// probably safe making a copy of the commands parameters instead.
    ///
    /// <code>
    /// IList&lt;Message&gt; dtos = context.Message
    ///     .Where(mq =&gt; context.Message.Where(w =&gt; w.LockDate &lt; lockExpiry).OrderBy(o =&gt; o.Id).Select(s =&gt; s.Id).Take(1).Contains(mq.Id))
    ///     .ExecuteUpdateGetRows(sp =&gt; sp.SetProperty(p =&gt; p.LockDate, now));
    /// </code>
    /// </remarks>
    private static object[] CopyParameters(DbCommand command)
    {
        object[] parameters = command.Parameters.Cast<DbParameter>().ToArray();
        return parameters;
    }

    /// <summary>
    /// A regex used to search the SQL for a comment -- ExecuteUpdateGetRows with a <see cref="Guid"/> updateId in numeric (N) format.
    /// </summary>
    [GeneratedRegex("^-- ExecuteUpdateGetRows (?<UpdateId>[0-9A-Fa-f]{32})\r?$", RegexOptions.Multiline | RegexOptions.ExplicitCapture)]
    private static partial Regex GetUpdateIdRegex();

    /// <summary>
    /// Check if the command executing is an ExecuteUpdate and the SQL contains an updateId.
    /// If it does then store the SQL and supress the commands execution.
    /// </summary>
    /// <param name="command">The command.</param>
    /// <param name="eventData">Contexual information about the command and execution.</param>
    /// <param name="result">The default return value for this method <see cref="InterceptionResult{int32}"/>.</param>
    /// <returns>The <see cref="ExecuteUpdateGetRowsSentinelResult"/> if the command is being supressed else <paramref name="result"/>.</returns>
    private InterceptionResult<int> HandleNonQueryExecuting(DbCommand command, CommandEventData eventData, InterceptionResult<int> result)
    {
        // There is a bug in EF core 9 where Db Interceptors can receive an obsolete value in CommandSource of BulkUpdate(8) instead of the
        // correct value ExecuteUpdate(8). So cast the CommandSource values to int's and compare by value instead.
        // https://github.com/dotnet/efcore/issues/34678
        if ((int)eventData.CommandSource == (int)CommandSource.ExecuteUpdate && GetUpdateId(command.CommandText, out Guid updateId))
        {
            this.StoreUpdateParameters(updateId, eventData.Context!, command);
            result = InterceptionResult<int>.SuppressWithResult(ExecuteUpdateGetRowsSentinelResult);
        }

        return result;
    }

    /// <summary>
    /// Store SQL and parameters for an ExecuteUpdate call.
    /// </summary>
    /// <param name="updateId">The updateId.</param>
    /// <param name="context">The database context.</param>
    /// <param name="command">The <see cref="DbCommand"/> containing the sql and parameters..</param>
    private void StoreUpdateParameters(Guid updateId, DbContext context, DbCommand command)
    {
        string sql = command.CommandText;
        object[] parameters = CopyParameters(command);

        if (!this._updateParameters.TryAdd(updateId, (context, sql, parameters)))
        {
            throw new InvalidOperationException("Unable to store an entry in UpdateParameters");
        }
    }

    #endregion private methods
}