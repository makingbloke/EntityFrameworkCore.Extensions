// Copyright ©2021-2025 Mike King.
// This file is licensed to you under the MIT license.
// See the License.txt file in the solution root for more information.

using Microsoft.EntityFrameworkCore.Diagnostics;
using System.Collections.Concurrent;
using System.Data.Common;
using System.Text.RegularExpressions;

namespace DotDoc.EntityFrameworkCore.Extensions.Interceptors;

/// <summary>
/// Interceptor for collecting the SQL generated by ExecuteUpdateGetRows methods.
/// </summary>
public sealed partial class ExecuteUpdateGetRowsCommandInterceptor : DbCommandInterceptor
{
    #region internal fields

    /// <summary>
    /// Singleton instance of this interceptor.
    /// </summary>
    internal static readonly ExecuteUpdateGetRowsCommandInterceptor Instance = new();

    /// <summary>
    /// Sentinel result returned when the ExecuteUpdateGetRows command is executed.
    /// </summary>
    internal static readonly int ExecuteUpdateGetRowsSentinelResult = int.MinValue;

    #endregion internal fields

    #region private fields

    /// <summary>
    /// Dictionary holding the collected ExecuteUpdate parameters.
    /// </summary>
    private readonly ConcurrentDictionary<Guid, (string, object[])> _updateParameters = new();

    #endregion private fields

    #region private constructors

    /// <summary>
    /// Initializes a new instance of the <see cref="ExecuteUpdateGetRowsCommandInterceptor"/> class.
    /// </summary>
    private ExecuteUpdateGetRowsCommandInterceptor()
    {
    }

    #endregion private constructors

    #region public methods

    /// <inheritdoc/>
    public override InterceptionResult<int> NonQueryExecuting(DbCommand command, CommandEventData eventData, InterceptionResult<int> result)
    {
        ArgumentNullException.ThrowIfNull(command);
        ArgumentNullException.ThrowIfNull(eventData);

        result = this.HandleNonQueryExecuting(command, eventData.CommandSource, result);
        return base.NonQueryExecuting(command, eventData, result);
    }

    /// <inheritdoc/>
    public override ValueTask<InterceptionResult<int>> NonQueryExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(command);
        ArgumentNullException.ThrowIfNull(eventData);

        result = this.HandleNonQueryExecuting(command, eventData.CommandSource, result);
        return base.NonQueryExecutingAsync(command, eventData, result, cancellationToken);
    }

    #endregion public methods

    #region internal methods

    /// <summary>
    /// Fetch the SQL and parameters for an ExecuteUpdateGetRows call.
    /// </summary>
    /// <param name="updateId">The updateId.</param>
    /// <param name="sql">The sql (out).</param>
    /// <param name="parameters">The parameters (out).</param>
    internal void FetchUpdateParameters(Guid updateId, out string sql, out object[] parameters)
    {
        if (!this._updateParameters.TryRemove(updateId, out (string Sql, object[] Parameters) entry))
        {
            throw new InvalidOperationException("Unable to fetch an entry from UpdateParameters");
        }

        sql = entry.Sql;
        parameters = entry.Parameters;
    }

    #endregion internal methods

    #region private methods

    /// <summary>
    /// Look in the SQL for a comment (EF Core Tag) and the <see cref="Guid"/> updateId.
    /// </summary>
    /// <param name="sql">The sql.</param>
    /// <param name="updateId">The <see cref="Guid"/> updateId (out).</param>
    /// <returns><see langword="true"/> if the comment is found and the updateId has been extracted else, <see langword="false"/>.</returns>
    private static bool GetUpdateId(string sql, out Guid updateId)
    {
        Match match = GetUpdateIdRegex().Match(sql);

        updateId = match.Success
            ? Guid.Parse(match.Groups["UpdateId"].Value)
            : Guid.Empty;

        return match.Success;
    }

    /// <summary>
    /// Clone a commands parameters.
    /// </summary>
    /// <param name="command">The command.</param>
    /// <returns>An array of cloned <see cref="DbParameter"/> objects.</returns>
    private static object[] CloneParameters(DbCommand command)
    {
        // We cannot use the IClonable interface and the clone method because not all
        // parameter objects support it (SqlParameter does but SqliteParameter does not).
        // So just clone the properties by copying the values into the new object.
        object[] parameters = new object[command.Parameters.Count];

        for (int i = 0; i < command.Parameters.Count; i++)
        {
            DbParameter srcParameter = command.Parameters[i];
            DbParameter dstParameter = command.CreateParameter();

            dstParameter.DbType = srcParameter.DbType;
            dstParameter.Direction = srcParameter.Direction;
            dstParameter.ParameterName = srcParameter.ParameterName;
            dstParameter.Precision = srcParameter.Precision;
            dstParameter.Scale = srcParameter.Scale;
            dstParameter.Size = srcParameter.Size;
            dstParameter.SourceColumn = srcParameter.SourceColumn;
            dstParameter.SourceColumnNullMapping = srcParameter.SourceColumnNullMapping;
            dstParameter.SourceVersion = srcParameter.SourceVersion;
            dstParameter.Value = srcParameter.Value;

            parameters[i] = dstParameter;
        }

        return parameters;
    }

    /// <summary>
    /// A regex used to search the SQL for a comment -- ExecuteUpdateGetRows with a <see cref="Guid"/> updateId in numeric (N) format.
    /// </summary>
    [GeneratedRegex("^-- ExecuteUpdateGetRows (?<UpdateId>[0-9A-Fa-f]{32})\r?$", RegexOptions.Multiline | RegexOptions.ExplicitCapture)]
    private static partial Regex GetUpdateIdRegex();

    /// <summary>
    /// Check if the command executing is an ExecuteUpdate and the SQL contains an updateId.
    /// If it does then store the SQL and supress the commands execution.
    /// </summary>
    /// <param name="command">The command.</param>
    /// <param name="commandSource">The command source.</param>
    /// <param name="result">The default return value for this method <see cref="InterceptionResult{int32}"/>.</param>
    /// <returns>The <see cref="ExecuteUpdateGetRowsSentinelResult"/> if the command is being supressed else <paramref name="result"/>.</returns>
    private InterceptionResult<int> HandleNonQueryExecuting(DbCommand command, CommandSource commandSource, InterceptionResult<int> result)
    {
        // There is a bug in EF core 9 where Db Interceptors can receive an obsolete value in CommandSource of BulkUpdate(8) instead of the
        // correct value ExecuteUpdate(8). So cast the CommandSource values to int's and compare by value instead.
        // https://github.com/dotnet/efcore/issues/34678
        if ((int)commandSource == (int)CommandSource.ExecuteUpdate && GetUpdateId(command.CommandText, out Guid updateId))
        {
            this.StoreUpdateParameters(updateId, command);
            result = InterceptionResult<int>.SuppressWithResult(ExecuteUpdateGetRowsSentinelResult);
        }

        return result;
    }

    /// <summary>
    /// Store SQL and parameters for an ExecuteUpdate call.
    /// </summary>
    /// <param name="updateId">The updateId.</param>
    /// <param name="command">The <see cref="DbCommand"/> containing the sql and parameters..</param>
    private void StoreUpdateParameters(Guid updateId, DbCommand command)
    {
        // Get the SQL and create a clone of the object parameters as they get destroyed when the command does.
        string sql = command.CommandText;
        object[] parameters = CloneParameters(command);

        if (!this._updateParameters.TryAdd(updateId, (sql, parameters)))
        {
            throw new InvalidOperationException("Unable to store an entry in UpdateParameters");
        }
    }

    #endregion private methods
}